|Property|Descripción|Opciones|
|--- |--- |--- |
|`abi.type`|**Tipo de ABI** &ndash; especifica el tipo ABI (interfaz binaria de aplicación) del dispositivo emulado. El **x86** opción es para la instrucción establecer suelen denominarse "x86" o "IA-32." El **x86_64** opción está habilitada la x86 64 bits conjunto de instrucciones. El **armeabi-v7a** opción es para el conjunto con las extensiones de ARM v7-a de instrucciones de ARM. El **arm64 v8a** opción es para el conjunto de instrucciones de ARM que admite AArch64.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Partición de caché** &ndash; determina si el dispositivo emulado usará una **/caché** partición en el dispositivo. El **/caché** partición (que inicialmente está vacía) es la ubicación donde Android almacena datos de acceso frecuente y componentes de aplicación. Si establece en **ningún**, el emulador no usará un **/caché** partición y el otro `disk.cache` se omitirá la configuración.|sí, no|
|`disk.cachePartition.path`|**Ruta de acceso de partición de caché** &ndash; especifica un archivo de imagen de la partición de caché en el equipo de desarrollo. El emulador usará este archivo para el **/caché** partición. Escriba una ruta de acceso absoluta o una ruta de acceso relativa al directorio de datos del emulador. Si no se establece, el emulador crea un archivo temporal vacío denominado **cache.img** en el equipo de desarrollo. Si el archivo no existe, se crea como un archivo vacío. Esta opción se omite si `disk.cachePartition` está establecido en **ningún**.||
|`disk.cachePartition.size`|**Tamaño de partición de caché** &ndash; el tamaño del archivo de partición de caché (en bytes). Normalmente no es necesario establecer esta opción, a menos que la aplicación vaya a descargar archivos mayores que el tamaño de caché predeterminado, de 66 megabytes. Esta opción se omite si `disk.cachePartition` está establecido en **ningún**. Si este valor es un entero, especifica el tamaño en bytes. También puede especificar el tamaño en kilobytes, megabytes y gigabytes anexando **K**, **M**, o **G** al valor. El tamaño mínimo es **9M** y el tamaño máximo es **1023G**.||
|`disk.dataPartition.initPath`|**Ruta de acceso inicial a la partición de datos** &ndash; especifica el contenido inicial de la partición de datos. Después de borrar datos de usuario, el emulador copia el contenido del archivo especificado a los datos de usuario (de forma predeterminada, **userdata-qemu.img**) en lugar de usar **userdata.img** como la versión inicial.||
|`disk.dataPartition.path`|**Ruta de acceso a la partición de datos** &ndash; especifica el archivo de partición de datos de usuario. Para configurar un archivo de datos de usuario persistentes, escriba un nombre de archivo y una ruta de acceso en el equipo de desarrollo. Si el archivo no existe, el emulador crea una imagen desde el archivo predeterminado **userdata.img**, lo almacena en el nombre de archivo especificado por `disk.dataPartition.path`, y conserva los datos de usuario a ella cuando se cierra el emulador. Si no especifica una ruta de acceso, el archivo predeterminado se denomina **userdata-qemu.img**. El valor especial **<temp>** hace que el emulador crear y usar un archivo temporal. Si `disk.dataPartition.initPath` se establece, su contenido se copiará en el `disk.dataPartition.path` archivo en tiempo de arranque. Tenga en cuenta que esta opción no puede dejarse en blanco.||
|`disk.dataPartition.size`|**Tamaño de la partición de datos** &ndash; especifica el tamaño de la partición de datos de usuario en bytes. Si este valor es un entero, especifica el tamaño en bytes. También puede especificar el tamaño en kilobytes, megabytes y gigabytes anexando **K**, **M**, o **G** al valor. El tamaño mínimo es **9M** y el tamaño máximo es **1023G**.||
|`disk.ramdisk.path`|**Ruta de acceso de disco RAM** &ndash; ruta de acceso a la imagen de arranque (disco RAM) de la partición. La imagen de disco RAM es un subconjunto de la imagen del sistema que el kernel carga antes de que se monte la imagen del sistema. La imagen de disco RAM suele contener archivos binarios de tiempo de arranque y scripts de inicialización. Si no se especifica esta opción, el valor predeterminado es **ramdisk.img** en el directorio de sistema del emulador.||
|`disk.snapStorage.path`|**Ruta de acceso de almacenamiento de instantáneas** &ndash; ruta de acceso al archivo de almacenamiento de instantáneas se almacenan todas las instantáneas. En este archivo se guardarán todas las instantáneas realizadas durante la ejecución. Únicamente se pueden restaurar durante la ejecución del emulador las instantáneas guardadas en este archivo. Si no se especifica esta opción, el valor predeterminado es snapshots.img en el directorio de datos del emulador.||
|`disk.systemPartition.initPath`|**Ruta de acceso de sistema partición init** &ndash; ruta de acceso a la copia de solo lectura del archivo de imagen del sistema; en concreto, la partición que contiene las bibliotecas de sistema y datos que se corresponde con el nivel de API y cualquier variante. Si no se especifica esta ruta de acceso, el valor predeterminado es system.img en el directorio de sistema del emulador.||
|`disk.systemPartition.path`|**Ruta de acceso de partición de sistema** &ndash; ruta de acceso a la imagen de partición de sistema de lectura/escritura. Si no se establece esta ruta de acceso, un archivo temporal se creará e inicializa con el contenido del archivo especificado por `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Tamaño de la partición del sistema** &ndash; el tamaño ideal de la partición del sistema (en bytes). El tamaño se omite si la imagen de la partición del sistema real es mayor que esta configuración; en caso contrario, se especifica el tamaño máximo que puede alcanzar el archivo de partición del sistema. Si este valor es un entero, especifica el tamaño en bytes. También puede especificar el tamaño en kilobytes, megabytes y gigabytes anexando **K**, **M**, o **G** al valor. El tamaño mínimo es **9M** y el tamaño máximo es **1023G**.||
|`hw.accelerometer`|**Acelerómetro** &ndash; determina si el dispositivo emulado contiene un sensor de acelerómetro. El acelerómetro ayuda al dispositivo a determinar orientación (usada para el giro automático). El acelerómetro informa de la aceleración del dispositivo a través de tres ejes de sensor.|sí, no|
|`hw.audioInput`|**Compatibilidad con la grabación de audio** &ndash; determina si el dispositivo emulado puede grabar audio.|sí, no|
|`hw.audioOutput`|**Compatibilidad con la reproducción de audio** &ndash; determina si el dispositivo emulado puede reproducir audio.|sí, no|
|`hw.battery`|**Compatibilidad con batería** &ndash; determina si el dispositivo emulado puede ejecutarse en una batería.|sí, no|
|`hw.camera`|**Compatibilidad con la cámara** &ndash; determina si el dispositivo emulado tiene una cámara.|sí, no|
|`hw.camera.back`|**Cámara trasera** &ndash; configura la cámara trasera (la lente alejándose del usuario). Si utilizas una cámara Web en el equipo de desarrollo para simular la cámara trasera del dispositivo emulado, este valor debe establecerse en la cámara Web*n*, donde _n_ selecciona la cámara Web (si tiene sólo una, Elija **webcam0**). Si el conjunto a emulado, el emulador simula la cámara en el software. Para deshabilitar la cámara trasera, establezca este valor en none. Si habilita la cámara trasera, asegúrese de habilitar también `hw.camera`.|emulado, ninguno, webcam0|
|`hw.camera.front`|**Cámara frontal** &ndash; configura la cámara frontal (la lente enfoca al usuario). Si utilizas una cámara Web en el equipo de desarrollo para simular la cámara frontal del dispositivo emulado, este valor debe establecerse en la cámara Web*n*, donde _n_ selecciona la cámara Web (si tiene sólo una Elija **webcam0**). Si el conjunto a emulado, el emulador simula una cámara en el software. Para deshabilitar la cámara frontal, establezca este valor en none. Si habilita la cámara frontal, asegúrese de habilitar también `hw.camera`.|emulado, ninguno, webcam0|
|`hw.camera.maxHorizontalPixels`|**Píxeles horizontales máximos de la cámara** &ndash; configura la resolución horizontal máxima de la cámara del dispositivo emulado (en píxeles).||
|`hw.camera.maxVerticalPixels`|**Píxeles verticales máximos de la cámara** &ndash; configura la resolución vertical máxima de la cámara del dispositivo emulado (en píxeles).||
|`hw.cpu.arch`|**Arquitectura de CPU** &ndash; arquitectura de CPU para emular el dispositivo virtual. Si usa Intel HAXM para la aceleración de hardware, seleccione **x86** para una CPU de 32 bits. Seleccione **x86_64** para un dispositivo acelerado por HAXM de 64 bits. (Asegúrese de instalar la imagen del sistema Intel x86 correspondiente en el Administrador de SDK: por ejemplo, Intel x86 Atom o Intel x86 Atom_64.) Para simular una CPU de ARM, seleccione **arm** para 32 bits o seleccione **arm64** para una CPU de ARM de 64 bits. Tenga en cuenta que los dispositivos virtuales basados en ARM se ejecutarán mucho más lentamente que los basados en x86, ya que la aceleración de hardware no está disponible para ARM.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**Modelo de CPU** &ndash; suele dejarse sin establecer este valor (se establecerá en un valor que se deriva de `hw.cpu.arch` si no se establece explícitamente). A pesar de ello, se puede establecer en una cadena específica del emulador para su uso experimental.||
|`hw.dPad`|**Teclas de DPad** &ndash; determina si el dispositivo emulado admite teclas del mando de dirección (DPad). Un DPad suele tener cuatro teclas para indicar el control direccional.|sí, no|
|`hw.gps`|**Compatibilidad con GPS** &ndash; determina si el dispositivo emulado tiene un receptor GPS (sistema de posicionamiento Global).|sí, no|
|`hw.gpu.enabled`|**Emulación de GPU** &ndash; determina si el dispositivo emulado admite la emulación de GPU. Cuando está habilitada, la emulación de GPU usa OpenGL para sistemas incrustados (OpenGL ES) para representar gráficos 2D y 3D en la pantalla, y la configuración del modo de emulación de GPU asociada determina cómo se implementa la emulación de GPU.|sí, no|
|`hw.gpu.mode`|**Modo de emulación de GPU** &ndash; determina cómo se implementa la emulación de GPU por el emulador. Si selecciona automático, el emulador elegirá la aceleración de hardware y software según la configuración del equipo de desarrollo. Si selecciona un host, el emulador usará el procesador de gráficos de su equipo de desarrollo para realizar la emulación de GPU para un procesamiento más rápido. Si la GPU no es compatible con el emulador y se encuentra en Windows, puede probar el ángulo, en lugar de host. El modo de ángulo usa DirectX para ofrecer un rendimiento similar al host. Si selecciona mesa, el emulador usará la biblioteca de software 3D de Mesa para representar gráficos. Seleccione mesa si tiene problemas de representación con el procesador de gráficos de su equipo de desarrollo. El modo de swiftshader puede usarse para representar gráficos mediante software con un rendimiento ligeramente inferior que el uso de GPU de su equipo. La opción off (emulación de hardware de gráficos disable) es una opción en desuso que puede producir la representación incorrecta de algunos elementos y, por lo tanto, no se recomienda.|automático, host, mesa, ángulo, swiftshader, desactivado|
|`hw.gsmModem`|**Compatibilidad con módem GSM** &ndash; determina si el dispositivo emulado incluye un módem que admite el sistema de radio de telefonía GSM (sistema Global para las comunicaciones móviles).|sí, no|
|`hw.initialOrientation`|**Orientación de la pantalla inicial del** &ndash; configura la orientación inicial de la pantalla del dispositivo emulado (modo vertical u horizontal). En el modo vertical, la pantalla es más alta que ancha. En el modo horizontal, la pantalla es más ancha que alta. Cuando se ejecuta el dispositivo emulado, puede cambiar la orientación si se admiten en el perfil del dispositivo el modo vertical y horizontal.|vertical, horizontal|
|`hw.keyboard`|**Compatibilidad con teclado** &ndash; determina si el dispositivo emulado admite un teclado QWERTY.|sí, no|
|`hw.keyboard.charmap`|**Nombre del mapa de caracteres del teclado** &ndash; el nombre del mapa de caracteres de hardware para este dispositivo. Nota: Esta debe ser siempre el valor predeterminado **qwerty2** a menos que se ha modificado la imagen del sistema en consecuencia. Este nombre se envía al kernel en el momento del arranque. Si se especifica un nombre incorrecto, el dispositivo virtual no se podrá usar.||
|`hw.keyboard.lid`|**Compatibilidad con tapa del teclado** &ndash; si está habilitada la compatibilidad con el teclado, esta configuración determina si el teclado QWERTY puede estar cerrado/oculto o abierto/visible. Esta opción se omitirá si hw.keyboard está establecida en false. Nota: el valor predeterminado es false si el dispositivo emulado tiene como destino el nivel de API 12 o superior.|sí, no|
|`hw.lcd.backlight`|**Luz de fondo de LCD** &ndash; determina si se simula una luz de fondo de LCD el dispositivo emulado.|sí, no|
|`hw.lcd.density`|**Densidad de LCD** &ndash; la densidad de la pantalla LCD emulada, medida en píxeles independientes de densidad o dp (dp es una unidad píxeles de virtuales). Si el valor es 160 dp, cada dp se corresponde con un píxel físico. En tiempo de ejecución, Android usa este valor para seleccionar y escalar los recursos/activos adecuados para la representación correcta de la pantalla.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**Profundidad de color de LCD** &ndash; la profundidad de bits del color del búfer de fotogramas emulado que contiene el mapa de bits para impulsar la pantalla LCD. Este valor puede ser 16 bits (65 536 colores posibles) o 32 bits (16 777 216 colores más transparencia). El valor de 32 bits puede hacer que el emulador se ejecute un poco más lentamente, pero con una mayor precisión del color.|16, 32|
|`hw.lcd.height`|**Alto de píxeles de LCD** &ndash; el número de píxeles que componen la dimensión vertical de la pantalla LCD emulada.||
|`hw.lcd.width`|**Ancho en píxeles de LCD** &ndash; el número de píxeles que componen la dimensión horizontal de la pantalla LCD emulada.||
|`hw.mainKeys`|**Las claves de hardware Atrás/inicio** &ndash; determina si el dispositivo emulado admite hardware Atrás y botones de navegación principal. Puede establecer este valor en **Sí** si los botones solo se implementan mediante software. Si `hw.mainKeys` está establecido en **Sí**, el emulador no mostrará los botones de navegación en la pantalla, pero puede usar el panel lateral del emulador para "presionar" estos botones.|sí, no|
|`hw.ramSize`|**Tamaño de la RAM de dispositivo** &ndash; la cantidad de memoria RAM física en el dispositivo emulado, en megabytes. El valor predeterminado se calcula a partir del tamaño de la pantalla o de la versión de la máscara. Si se aumenta el tamaño, el emulador puede funcionar más rápidamente, pero a cambio solicitará más recursos al equipo de desarrollo.||
|`hw.screen`|**Tipo de pantalla táctil** &ndash; define el tipo de pantalla del dispositivo emulado. Una pantalla multitoque puede realizar un seguimiento de dos o más dedos en la interfaz táctil. Una pantalla táctil puede detectar solo los eventos de toque de un solo dedo. Una pantalla sin intervención del usuario no detecta eventos de toque.|táctil, multitáctil, no táctil|
|`hw.sdCard`|**Compatibilidad con SDCard** &ndash; determina si el dispositivo emulado admite la inserción y extracción de tarjetas SD (Secure Digital) virtuales. El emulador usa las imágenes de disco montables almacenadas en el equipo de desarrollo para simular las particiones de los dispositivos de tarjeta SD reales (vea hw.sdCard.path).|sí, no|
|`sdcard.size`|**Tamaño de SDCard** &ndash; especifica el tamaño del archivo de tarjeta SD virtual en la ubicación especificada por `hw.sdCard.path`. está disponible en el dispositivo (en bytes). Si este valor es un entero, especifica el tamaño en bytes. También puede especificar el tamaño en kilobytes, megabytes y gigabytes anexando **K**, **M**, o **G** al valor. El tamaño mínimo es **9M** y el tamaño máximo es **1023G**.||
|`hw.sdCard.path`|**Ruta de acceso de imagen de SDCard** &ndash; especifica el nombre de archivo y ruta de acceso a un archivo de imagen de partición de tarjeta SD en el equipo de desarrollo. Por ejemplo, se podría establecer esta ruta de acceso **C:\sd\sdcard.img** en Windows.||
|`hw.sensors.magnetic_field`|**Sensor de campo magnético** &ndash; determina si el dispositivo emulado admite un sensor de campo magnético. El sensor de campos magnético (también conocido como magnetómetro) notifica el campo geomagnético ambiental según las mediciones de tres ejes del sensor. Habilite esta opción para las aplicaciones que necesiten tener acceso a las lecturas de una brújula. Por ejemplo, una aplicación de navegación podría usar este sensor para detectar en qué dirección está orientado el usuario.|sí, no|
|`hw.sensors.orientation`|**Sensor de orientación** &ndash; determina si el dispositivo emulado proporciona orientación de los valores del sensor. El sensor de orientación mide los grados de rotación que realiza un dispositivo en torno a tres físicos ejes (x, y, z). Tenga en cuenta que el sensor de orientación está en desuso a partir de Android 2.2 (nivel de API 8).|sí, no|
|`hw.sensors.proximity`|**Sensor de proximidad** &ndash; determina si el dispositivo emulado admite un sensor de proximidad. Este sensor mide la proximidad de un objeto con respecto a la pantalla de un dispositivo. Este sensor suele usarse para determinar si se está sujetando un auricular junto a la oreja de una persona.|sí, no|
|`hw.sensors.temperature`|**Sensor de temperatura** &ndash; determina si el dispositivo emulado admite un sensor de temperatura. Este sensor mide la temperatura del dispositivo en grados centígrados (&deg;C).|sí, no|
|`hw.touchScreen`|**Compatibilidad con pantalla táctil** &ndash; determina si el dispositivo emulado admite una pantalla táctil. La pantalla táctil se usa para la manipulación directa de los objetos en la pantalla.|sí, no|
|`hw.trackBall`|**Compatibilidad con bola de seguimiento** &ndash; determina si el dispositivo emulado admite una bola de seguimiento.|sí, no|
|`hw.useext4`|**Compatibilidad con sistema de archivos EXT4** &ndash; determina si el dispositivo emulado usa el sistema de archivos Linux EXT4 para las particiones. Dado que el tipo de sistema de archivos ahora se detecta automáticamente, esta opción está en desuso y se omite.|No|
|`kernel.newDeviceNaming`|**Nomenclatura de dispositivo nuevo kernel** &ndash; se utiliza para especificar si el kernel requiere un nuevo esquema de nomenclatura de dispositivo. Se suele usar con kernels de Linux 3.10 y versiones posteriores. Si establece en **autodetect**, el emulador detectará automáticamente si el kernel requiere un nuevo esquema de nomenclatura de dispositivo.|detección automática, sí, no|
|`kernel.parameters`|**Los parámetros de kernel** &ndash; especifica la cadena de parámetros de arranque de kernel de Linux. De forma predeterminada, este valor se deja en blanco.||
|`kernel.path`|**Ruta de acceso de kernel** &ndash; especifica la ruta de acceso al kernel de Linux. Si no se especifica esta ruta de acceso, el emulador busca en el directorio de sistema del emulador de kernel-ranchu.||
|`kernel.supportsYaffs2`|**Compatibilidad con particiones YAFFS2** &ndash; determina si el kernel admite particiones YAFFS2 particiones (todavía otra Flash File System 2). Normalmente, esto solo se aplica a los kernels anteriores a Linux 3.10. Si establece en **autodetect** el emulador detectará automáticamente si el kernel puede montar sistemas de archivos YAFFS2.|detección automática, sí, no|
|`skin.name`|**Nombre de máscara** &ndash; el nombre de una máscara del emulador de Android. Una máscara es una colección de archivos que define los elementos visuales y de control de una pantalla del emulador y describe el aspecto que tendrá la ventana del dispositivo virtual Android en el equipo de desarrollo. Una máscara describe el tamaño de la pantalla, los botones y el diseño global, pero no afecta al funcionamiento de la aplicación.||
|`skin.path`|**Ruta de acceso de la máscara** &ndash; ruta de acceso al directorio que contiene los archivos de máscara del emulador especificado en skin.name este directorio contiene archivos de diseño hardware.ini y archivos de imagen para los elementos de la máscara.||
|`skin.dynamic`|**Máscara dinámica** &ndash; o no la máscara es dinámica. La máscara del emulador es dinámica si el emulador va a construir una máscara de un tamaño determinado en función de una anchura y una altura especificadas.|No|

